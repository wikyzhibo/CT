## 文件
- 网文件
  - N1p21t16.CSV "25届两道工序，第一道5个并行腔体"
  - N4p20t16.csv "毕设案例一网"
  - PetriNet 文件夹
    - acstract_of_CT：将组合设备的buffer抽象出来研究控制库所
      - bm2_controller.ndr  BM容量为2且带控制器
      - bm2.ndr BM容量为2不带控制器
      - bm1_controller.ndr BM容量为1且带控制器
      - bm1.ndr BM容量为1不带控制器
      - bm2_controller_circle.ndr BM容量为2且带控制器（回环）
    - N1：毕设案例一网
    - N2：吴亚丽和刘瑞琼的组合设备例子
      - N2.ndr 没有控制库所的网
      - net.ndr 加上控制库所
    - N3：一个判断死锁的简单案例
    - N4：离散作业中的网，它可以作为检测坏标识的案例
  - 程序文件
    - net.py "Petri网文件"
    - CT_env.py "组合设备环境文件"
    - train_CT.py "ppo训练文件"
    - solutions/PPO/data_collector.py "自定义的PPO采样器，避免SyncDataCollector遇到死锁时截断（详见 solutions/PPO/data_collector.md）"
    - tmp.py "随机森林识别死锁"
    - markbuffer.py "获取标识文件"
- out.csv "输出(变迁时间，变迁序列），matlab那边的程序绘制甘特图"
- CT.pt "policy模型文件"

## Docs

- docs/pn.md：`pn.py` 使用与架构概览
- docs/pn_api.md：`pn.py` API 文档
- docs/pn_design.md：`pn.py` 设计说明


## Log

#### 构造组合设备的环境（10月15日-10月29日）

 

##### **调度实现**

- [x] 复现：单步贪婪，剪枝
  - 单步贪婪快，但是到不了最优，特别是wafer数变多的时候
  - 考虑是不是要把蚁群算法移植到python

- [x] **抽象动作集**：把动作集更换成从工序i到工序i+1，N2可以达到最优，时间也比较短
- [ ] **训练时间加速思路**：每次模型terminated的时候重置到初始标识，因此走得很慢，可以这样想：因为我是有一个潜势函数的，所以我可以按照加工进度往回退到某一个节点。
  - 思路一：随机热启动，模型重置后随机走k步，k in [min, max]
  - 思路二：从死锁处回退k步
- [x] 局部观察
  - [x] 去掉闲置库所，使用部分观察进行训练。去掉起始库所和末端的库所observation=observation[1:-1]后还是可以收敛，并且50batch就可以到达最优附近，后面的训练主要收到死锁、死状态的困扰。**这里[1：-1]有问题制库所不是最前面和最后面**

- [x] **单机器手死锁惩罚**：目前想解决“如何识别坏标识”这个问题，在这个环境中，坏标识的产生有两种可能：某一个机器手自己把自己卡住，另一种是两个机器手因为互相影响而卡住，针对第一种情况，可以在一个机器手发生死锁给一个惩罚。根据得到的结果，这个思路好像让模型的最短时间变得更长了！！！通过观察10个batch里面的总deadlock数量，发现训练初期10个batch以内，死锁数很多，而且迅速下降。可以这样认为：**有一些死锁在初期已经被模型学会，剩下的死锁模型即使增加训练也无法识别、学习。**
- [x] **强化学习训练经验**：
  - **死锁惩罚够大：**一开始死锁惩罚小500，导致模型故意陷入死锁达到奖励最大。解决方法：令死锁惩罚大于最短总时间（5500），10000的死锁惩罚可以让其跑完整个历程。
  - 增大sub_batch_size(256)后300个batch到达不了最优，放到autodl-4090也没办法加快训练速度。解决方法：减小sub_batch_size(64)，训练700个batch，最终可以达到5800左右的makespan。
  - **网络隐藏层：**N1p21t16 这个网如果policy的hidden 太小64或者128它是到不了头的 
- [ ] 使用多智能体



##### **死锁控制方面**

- [x] 得到当机器手容量为1、BM2容量为1或2的最大允许控制器
  - 进行死锁分析时，可以将原始网（复杂）的某个部分进行抽象成简单的网进行测试
  - 若进行环状连起来之后，还是有死锁孙在的


- [x] 训练1个“死锁”检测模型。
    - [x] Petri.find_bad_mark	找出坏标识和死标识
    - [x] 使用随机森林算法训练识别模型（当树的最大深度为10时，效果很差。通过调整深度为20时，坏和死标识的正确率显著上升，但是5折交叉验证中，[80   596] 效果还是比较勉强）
    - [ ] 死锁标识进行聚类分析



##### helper 函数

- [ ] get_rg 可达图









组会一

- 信息一：构造链条
- 
- 问题一：ppo在遇到驻留时间时没办法处理
- 问题二：因为硬件动作延迟导致需要纠偏问题（即“重新规划”），及是否需要纠偏
- 问题三：已有算法不能移植到“清洗机”模型上





- 滞留惩罚
- 并行腔室工作负载差异较大惩罚



























































