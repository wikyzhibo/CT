## 文件
- 网文件
  - N1p21t16.CSV "25届两道工序，第一道5个并行腔体"
  - N4p20t16.csv "毕设案例一网"
  - PetriNet 文件夹
    - acstract_of_CT：将组合设备的buffer抽象出来研究控制库所
      - bm2_controller.ndr  BM容量为2且带控制器
      - bm2.ndr BM容量为2不带控制器
      - bm1_controller.ndr BM容量为1且带控制器
      - bm1.ndr BM容量为1不带控制器
      - bm2_controller_circle.ndr BM容量为2且带控制器（回环）
    - N1：毕设案例一网
    - N2：吴亚丽和刘瑞琼的组合设备例子
      - N2.ndr 没有控制库所的网
      - net.ndr 加上控制库所
    - N3：一个判断死锁的简单案例
    - N4：离散作业中的网，它可以作为检测坏标识的案例
- 程序文件
  - net.py "Petri网文件"
  - CT_env.py "组合设备环境文件"
  - train_CT.py "ppo训练文件"
  - tmp.py "随机森林识别死锁"
  - markbuffer.py "获取标识文件"
- out.csv "输出(变迁时间，变迁序列），matlab那边的程序绘制甘特图"
- CT.pt "policy模型文件"


## Log

#### 构造组合设备的环境（10月15日-10月29日）

 

##### **调度实现**

- [x] 复现：单步贪婪，剪枝
  - 单步贪婪快，但是到不了最优，特别是wafer数变多的时候
  - 考虑是不是要把蚁群算法移植到python

- [x] **抽象动作集**：把动作集更换成从工序i到工序i+1，N2可以达到最优，时间也比较短
- [ ] **训练时间加速思路**：每次模型terminated的时候重置到初始标识，因此走得很慢，可以这样想：因为我是有一个潜势函数的，所以我可以按照加工进度往回退到某一个节点。
  - 思路一：随机热启动，模型重置后随机走k步，k in [min, max]
  - 思路二：从死锁处回退k步
- [x] 局部观察
  - [x] 去掉闲置库所，使用部分观察进行训练。去掉起始库所和末端的库所observation=observation[1:-1]后还是可以收敛，并且50batch就可以到达最优附近，后面的训练主要收到死锁、死状态的困扰。**这里[1：-1]有问题制库所不是最前面和最后面**

- [x] **单机器手死锁惩罚**：目前想解决“如何识别坏标识”这个问题，在这个环境中，坏标识的产生有两种可能：某一个机器手自己把自己卡住，另一种是两个机器手因为互相影响而卡住，针对第一种情况，可以在一个机器手发生死锁给一个惩罚。根据得到的结果，这个思路好像让模型的最短时间变得更长了！！！通过观察10个batch里面的总deadlock数量，发现训练初期10个batch以内，死锁数很多，而且迅速下降。可以这样认为：**有一些死锁在初期已经被模型学会，剩下的死锁模型即使增加训练也无法识别、学习。**
- [x] **强化学习训练经验**：
  - **死锁惩罚够大：**一开始死锁惩罚小500，导致模型故意陷入死锁达到奖励最大。解决方法：令死锁惩罚大于最短总时间（5500），10000的死锁惩罚可以让其跑完整个历程。
  - 增大sub_batch_size(256)后300个batch到达不了最优，放到autodl-4090也没办法加快训练速度。解决方法：减小sub_batch_size(64)，训练700个batch，最终可以达到5800左右的makespan。
  - **网络隐藏层：**N1p21t16 这个网如果policy的hidden 太小64或者128它是到不了头的 
- [ ] 使用多智能体



##### **死锁控制方面**

- [x] 得到当机器手容量为1、BM2容量为1或2的最大允许控制器
  - 进行死锁分析时，可以将原始网（复杂）的某个部分进行抽象成简单的网进行测试
  - 若进行环状连起来之后，还是有死锁孙在的


- [x] 训练1个“死锁”检测模型。
    - [x] Petri.find_bad_mark	找出坏标识和死标识
    - [x] 使用随机森林算法训练识别模型（当树的最大深度为10时，效果很差。通过调整深度为20时，坏和死标识的正确率显著上升，但是5折交叉验证中，[80   596] 效果还是比较勉强）
    - [ ] 死锁标识进行聚类分析



##### helper 函数

- [ ] get_rg 可达图










































## 读论文

25年 吴亚丽 陈玉峰：多步寻优策略

- 建模
  - LP->(PM11 or PM12 or BM1->PM3-PM6->BM->LP)
- 什么叫多步寻优策略
  - 贪婪策略：当前全局事件改变量最小的变迁优先发射，若死锁则退回到上一个状态，并且不会访问已经搜索过的状态。一旦搜索到终止标识，立刻返回。
  - 多步策略：走N步，看看怎么走时间改变量最小
- 做实验
  - 对比：单步寻优搜索算法、多步寻优搜索算法、 Dijkstra 算法以及引入移动窗口的 DWSD 算法
  - 构造两个复杂度不同的案例（案例一标识数60万，案例二标识数5万） 
  - 评价指标：完工时间、程序运行时间（0.1s-4.3s）、拓展标识数（拓展了11329670个标识）
  - 完工时间 - 晶圆数 曲线
- 展望
  - 网模型更新（有色Petri网、分层Petri网、面向资源Petri网）；
  - 基于强化学习的自适应搜索框架
  - 设备故障、加工时间波动、紧急插单不确定时间发生
  - 晶圆重入、多种晶圆混合加工、驻留时间等复杂约束





















































