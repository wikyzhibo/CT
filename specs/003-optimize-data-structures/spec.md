# Feature Specification: 在 002-sim-speedup 基础上优化数据结构以进一步加速

**Feature Branch**: `003-optimize-data-structures`  
**Created**: 2026-01-26  
**Status**: Draft  
**Input**: User description: "在002-sim-speedup的基础上，尝试优化数据结构达到加速效果"

## User Scenarios & Testing *(mandatory)*

### User Story 1 - 通过数据结构优化进一步提升模拟性能 (Priority: P1)

在 002-sim-speedup 已实现的性能优化基础上，研究人员和强化学习训练系统需要进一步优化数据结构的存储和访问方式，减少内存访问开销、属性查找开销和对象创建开销，从而进一步提升整体模拟性能。

**Why this priority**: 在算法和计算逻辑优化（002-sim-speedup）之后，数据结构优化是进一步提升性能的关键方向。通过优化数据结构的布局、访问模式和内存使用，可以减少 CPU 缓存未命中、减少属性查找开销、减少对象创建和销毁的开销，从而在相同硬件上获得更好的性能。

**Independent Test**: 可以通过运行固定数量的模拟步数（例如 100,000 步）并测量实际执行时间来进行独立测试。在启用数据结构优化后，系统应在标准开发机器上，使用训练模式配置（with_reward=True, detailed_reward=False, 极速模式启用），在相同时间内执行更多模拟步数，或执行相同步数的时间更短。

**Acceptance Scenarios**:

1. **Given** 一个已启用 002-sim-speedup 优化的 Petri 网模拟器（进一步启用数据结构优化），**When** 在标准开发机器上执行 100,000 个模拟步数，**Then** 总执行时间小于1s
3. **Given** 批量训练场景（已启用 002-sim-speedup + 数据结构优化），**When** 连续运行 100 个 episode，**Then** 总执行时间应比仅启用 002-sim-speedup 时减少至少 5%，且核心功能（状态转换、奖励计算）保持一致

---

### User Story 2 - 保持功能一致性和兼容性 (Priority: P1)

数据结构优化不应改变模拟器的核心行为或结果，确保优化后的模拟器产生与优化前相同的状态转换和奖励计算。同时，优化后的数据结构应与 002-sim-speedup 的优化措施兼容，可以同时启用。

**Why this priority**: 数据结构优化必须以不改变核心功能为前提，否则优化将失去意义。训练系统依赖模拟器行为的可重复性和准确性。核心功能的一致性确保训练结果的有效性。与 002-sim-speedup 的兼容性确保用户可以同时受益于两种优化措施。

**Independent Test**: 可以通过运行相同的随机种子和动作序列，比较优化前后的最终状态、奖励序列和核心事件日志来进行独立测试。核心功能结果应完全一致。同时，可以验证数据结构优化与 002-sim-speedup 的优化措施可以同时启用且不冲突。

**Acceptance Scenarios**:

1. **Given** 相同的初始状态和随机种子，**When** 执行相同的动作序列（启用数据结构优化），**Then** 优化后的模拟器应产生与优化前相同的最终状态、token 分布和总奖励
2. **Given** 相同的配置参数，**When** 运行完整的 episode（启用数据结构优化），**Then** 优化后的模拟器应产生相同的完成时间、报废事件和核心奖励值
3. **Given** 同时启用 002-sim-speedup 和数据结构优化，**When** 运行模拟，**Then** 两种优化措施应协同工作，不产生冲突或错误
4. **Given** 相同的输入序列，**When** 检查所有中间状态（启用数据结构优化），**Then** 优化后的模拟器在每个步骤的核心状态应与优化前完全匹配

---

### Edge Cases

- 当数据结构优化与 002-sim-speedup 的优化措施同时启用时，是否会产生冲突或性能退化？
- 当 `marks` 列表为空或只有一个元素时，数据结构优化是否仍然有效？
- 当库所数量非常大（例如 100+ 个库所）时，数据结构优化是否仍然有效？
- 当某些库所的 `tokens` 队列为空时，数据结构优化是否仍然有效？
- 当频繁访问特定类型的库所（如 type=1 的加工腔室）时，数据结构优化是否能够利用访问模式？
- 当需要克隆数据结构时（如 `reset` 操作），优化后的数据结构是否仍然支持高效的克隆？
- 当需要序列化或反序列化数据结构时，优化后的数据结构是否仍然兼容？
- 当内存使用受限时，数据结构优化是否会导致内存使用增加？

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: 系统必须优化 `marks` 列表的存储和访问方式，减少列表遍历和索引访问的开销
- **FR-002**: 系统必须优化 `Place` 类的内存布局，减少对象开销和属性访问开销（如使用 `__slots__` 或类似技术）
- **FR-003**: 系统必须优化 `BasedToken` 类的内存布局，减少对象创建和属性访问的开销
- **FR-004**: 系统必须优化 `Place.tokens` 的存储方式，减少 `deque` 操作的开销
- **FR-005**: 系统必须优化 `Place.release_schedule` 的存储方式，减少查找和更新操作的开销
- **FR-006**: 系统必须优化字典访问（如 `id2p_name`、`id2t_name`、`release_chain`），减少查找开销
- **FR-007**: 系统必须优化 NumPy 数组的访问模式，减少不必要的数组复制和转换
- **FR-008**: 系统必须支持按类型分组访问 `marks`，避免遍历所有库所（如只访问 type=1 的加工腔室）
- **FR-009**: 系统必须在优化后保持核心功能的行为一致性，包括状态转换、奖励计算、报废检测等
- **FR-010**: 系统必须确保优化后的数据结构与 002-sim-speedup 的优化措施兼容，可以同时启用
- **FR-011**: 系统必须支持 `marks` 列表的克隆操作（如 `reset` 中的 `_clone_marks`），确保克隆后的行为一致
- **FR-012**: 系统必须确保优化后的数据结构与现有代码兼容，不破坏现有的 API 接口
- **FR-013**: 系统必须优化缓存数据结构的访问，减少重复计算和查找（如 `_pre_places_cache`、`_pst_places_cache`）

### Key Entities

- **marks 列表**: Petri 网中所有库所（Place）的列表，是模拟器中最频繁访问的数据结构之一
- **Place 对象**: 表示 Petri 网中的一个库所，包含名称、容量、加工时间、类型、token 队列等属性
- **BasedToken 对象**: 表示 Petri 网中的一个 token，包含进入时间、停留时间、token ID、机器编号等属性
- **优化后的数据结构**: 经过优化的数据存储和访问方式，可能包括内存布局优化、缓存、分组、访问模式优化等
- **002-sim-speedup 优化措施**: 已实现的算法和计算逻辑优化，包括向量化、缓存索引、极速模式等

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: 在相同硬件配置下，执行 10000 个模拟步数的总执行时间应比仅启用 002-sim-speedup 时减少至少 5%
- **SC-003**: 在批量训练场景下（连续运行 100 个 episode），总执行时间应比仅启用 002-sim-speedup 时减少至少 5%
- **SC-004**: 优化后的模拟器在相同输入下应产生与优化前相同的核心结果（状态、奖励、核心事件），核心功能一致性达到 100%
- **SC-005**: 优化后的数据结构不应增加内存使用量超过 10%，确保优化不会导致内存问题
- **SC-006**: 在启用数据结构优化的情况下，模拟器应能稳定运行至少 10000 个 episode 而不出现性能退化或错误
- **SC-007**: 对于频繁访问数据结构的操作（如奖励计算、状态更新），执行时间应比仅启用 002-sim-speedup 时减少至少 8%
- **SC-008**: 数据结构优化应与 002-sim-speedup 的优化措施兼容，可以同时启用且不产生冲突或错误

## Assumptions

- 用户主要关注 CPU 计算性能，而非内存使用（在合理范围内，增加不超过 10%）
- 性能优化主要针对单线程执行场景，多线程优化不在本次范围
- 现有的 Petri 网结构和业务逻辑保持不变，只优化数据结构的存储和访问方式
- 用户接受通过配置开关来控制优化措施，而非硬编码优化
- 性能测试将在标准开发机器（现代 CPU，如 Intel i7/AMD Ryzen 7 或同等性能）上进行
- `marks` 列表的大小在运行时基本保持不变（库所数量固定）
- 优化措施主要针对频繁访问的场景，而非一次性初始化操作
- 002-sim-speedup 的优化措施已经实现并可用
- 数据结构优化可以与 002-sim-speedup 的优化措施同时启用

## Dependencies

- 依赖于现有的 `solutions/Continuous_model/pn.py` 实现
- 依赖于 `solutions/Continuous_model/construct.py` 中的 `Place` 和 `BasedToken` 类定义
- 依赖于 002-sim-speedup 的优化措施（向量化、缓存索引、极速模式等）
- 需要与强化学习训练系统（`solutions/PPO`）保持兼容
- 需要与可视化系统（`solutions/Continuous_model/visualize_env.py`）保持兼容
- 需要与现有的性能优化措施（`002-sim-speedup`）兼容

## Out of Scope

- 多线程或并行化优化（本次仅优化单线程性能）
- 改变 Petri 网的数学模型或业务逻辑
- 优化网络 I/O 或文件读写性能
- 优化可视化渲染性能（仅优化模拟器核心逻辑）
- 改变 API 接口或数据结构的外部接口
- 重新实现算法逻辑（本次仅优化数据结构，算法逻辑优化已在 002-sim-speedup 中完成）
- 优化 `deque` 的内部实现（使用标准库实现，仅优化使用方式）
